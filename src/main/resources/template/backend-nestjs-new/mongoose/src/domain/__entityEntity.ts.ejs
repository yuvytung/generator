<%
const { Case, typeDetect } = _;
const { _name, name , documentation, fields, relationships } = _entity;
const relationshipType = {
    O2O: "one-to-one",
    O2M: "one-to-many",
    M2O: "many-to-one",
    M2M: "many-to-many"
};
const entityName = _entity.name.pascal().concat(entitySuffix);
const relationshipsEntities = Array.from(new Set(relationships
        .map(r => r.otherEntityName)
        .filter(v => v.lower() !== name.lower())))
        .map((otherEntityName)=>
                `${otherEntityName.pascal().concat(entitySuffix)},`)
        .join(`\n`)
const importEntities = `import { ${relationshipsEntities} } from '.';`

-%>
import { Prop, Schema, SchemaFactory } from "@nestjs/mongoose";
import mongoose from "mongoose";
import { BaseEntity } from "../common/bases";
import { EntitiesEnum } from "../common/enums/EntitiesEnum";

<%-importEntities%>
<%-fields.filter(f => f.fieldValues)
        .map((f)=> `import { ${f.fieldType.pascal()} } from "./enum/${f.fieldType.kebab()}.enum";`)
%>


/**
* <%-name.pascal()%> entity.
*
* <%-documentation?.replace(/\\n/g,`
 * `)%>
*/
@Schema({ collection: EntitiesEnum.<%-entityName%> })
export class <%-entityName%> extends BaseEntity {
<%-
fields?.map(field =>
        `/**
   * ${field.documentation?.replace(/\\n/g,`
   * `) || field.fieldName}
   */
  @Prop({
    name: "${field.fieldName.snake()}",
    ${field.fieldValidateRules?.includes('required') ? "nullable: true," : ""}
    ${field.fieldValidateRules?.includes('unique') ? "unique: true," : ""}
    ${field.options?.any ? "type: Object," : ""}
    ${field.fieldValues ? "type: String, enum: ".concat(typeDetect(field.fieldType).pascal()) : ""}
  })
  ${Case.camel(field.fieldName).concat(field.fieldValidateRules?.includes('unique') ? "" : "?")}: ${field.options?.any ? "any" : typeDetect(field.fieldType)};`
).join(`

  `)
%>

<%-relationships?.map(relationship => {
    let propBuilder = '';
    if (relationshipType.O2O === relationship.relationshipType)
        propBuilder = relationship.options?.ref || !relationship.options?.any ? `
  @Prop({
    type: mongoose.Schema.Types.ObjectId,
    ref: EntitiesEnum.${relationship.otherEntityName.pascal()},
    select: true,
  })
  ` : `
  @Prop({ type: Object })
  `;
    else if (relationshipType.M2O === relationship.relationshipType)
        propBuilder = relationship.options?.ref || !relationship.options?.any ?`
  @Prop({
    type: mongoose.Schema.Types.ObjectId,
    ref: EntitiesEnum.${relationship.otherEntityName.pascal()}
  })
  ` : `
  @Prop({ type: Object })
  `;
    else if (relationshipType.O2M === relationship.relationshipType)
        propBuilder =  relationship.options?.ref || !relationship.options?.any ? `
  @Prop({
    type: [{ type: mongoose.Schema.Types.ObjectId, ref: EntitiesEnum.${relationship.otherEntityName.pascal()} }],
    select: false,
  })
  ` : `
  @Prop({ type: [{ type: Object }] })
  `;
    //   else if (relationshipType.M2M === relationship.relationshipType)
    //     propBuilder =  relationship.options?.ref ? `
    // @Prop({ type: [{ type: mongoose.Schema.Types.ObjectId, ref: EntitiesEnum.${relationship.otherEntityName.pascal()} }] })
    // ` : `
    // @Prop({ type: [{ type: Object }] })
    // `;

    if (
            (relationshipType.O2O === relationship.relationshipType) ||
            (relationshipType.M2O === relationship.relationshipType)
    )
        return propBuilder.concat(`${Case.camel(relationship.relationshipName)}?: ${Case.pascal(relationship.otherEntityName)};`);
    else if ((relationshipType.O2M === relationship.relationshipType)
            // || (relationshipType.M2M === relationship.relationshipType && relationship.ownerSide)
            // || (relationshipType.M2M === relationship.relationshipType && !relationship.ownerSide)
    )
        return propBuilder.concat(`${Case.camel(relationship.relationshipName)}s?: ${Case.pascal(relationship.otherEntityName)}[];`);
}).join(``)%>

}

export const <%-entityName%>Schema = SchemaFactory.createForClass(<%-entityName%>);
<%-entityName%>Schema.set("timestamps", { createdAt: "_createdAt", updatedAt: "_updatedAt" });



